import asyncio
import time
from pathlib import Path
from typing import Literal, Any
import os, shutil
from dotenv import load_dotenv
from langchain_community.callbacks import OpenAICallbackHandler
from langchain_core.messages import HumanMessage
from langchain_core.output_parsers import PydanticOutputParser
from langchain_core.runnables import RunnableConfig
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_openai import ChatOpenAI
from langgraph.checkpoint.memory import MemorySaver
from langgraph.prebuilt import create_react_agent
from langgraph.graph import StateGraph, START, END, MessagesState
from langgraph.types import Command
from pydantic import BaseModel
from typing import List
from pydantic import BaseModel, Field

from agents.utils import get_logger

load_dotenv()
OUTPUT_DIR = 'scope_pipeline'
EXTRA_DIR = 'data'
INSTRUCTIONS_DIR = Path(__file__).resolve().parent
try:
    shutil.rmtree(OUTPUT_DIR)
    shutil.rmtree(EXTRA_DIR)
    shutil.rmtree(os.path.join(OUTPUT_DIR, "interfaces"))
except Exception as e:
    pass
os.makedirs(OUTPUT_DIR, exist_ok=True)
os.makedirs(EXTRA_DIR, exist_ok=True)
os.makedirs(f"{OUTPUT_DIR}/interfaces", exist_ok=True)
NO_RESPONSE_MESSAGE = "Unable to receive the last message."
logger = get_logger("agents")


# Define shared state schema
class ScopeState(MessagesState):
    query: str
    requirements: str | list
    objectives: str | list
    deliverables: str | list
    whole_data: dict
    panels: str | list
    verification: str | list
    panel: str
    panel_name: str
    module: str
    module_name: str
    whole_file_data: str
    whole_data: dict

#
llm = ChatGoogleGenerativeAI(model="gemini-2.0-flash-lite", google_api_key=os.environ.get('GOOGLE_API_KEY'),
                             temperature=0.7)
# fastest_llm = ChatOpenAI(model="gpt-4.1-nano", api_key=os.environ.get('OPENAI_API_KEY_INTERNAL_TOOLS'))
# average_llm = ChatOpenAI(model="gpt-4o-mini", api_key=os.environ.get('OPENAI_API_KEY_INTERNAL_TOOLS'))
# intelligent_llm = ChatOpenAI(model="gpt-4.1-mini", api_key=os.environ.get('OPENAI_API_KEY_INTERNAL_TOOLS'))
# llm = ChatOpenAI(model="o4-mini", api_key=os.environ.get('OPENAI_API_KEY_INTERNAL_TOOLS'),
#                                 reasoning_effort="medium")

verifier_options = [
    "project_understanding_agent",
    "key_objectives_agent",
    "deliverables_agent",
    # "modules_agent",
    "modules_actions_agent",
]


class AgentRoute(BaseModel):
    name: str
    instructions: str


class Router(BaseModel):
    sequence: list[AgentRoute]


class SimpleRouter(BaseModel):
    next: str
    verification: str
    panel_name: str | None
    module_name: str | None


class Entity(BaseModel):
    name: str = Field(..., description="The title or identifier")
    description: str = Field(..., description="A concise description of the its purpose")


class EntityList(BaseModel):
    entities: List[Entity] = Field(
        ...,
        description="A list of entities generated by the model"
    )


callback_handler = OpenAICallbackHandler()


def generate_token_usage_str(cb):
    return (f"Tokens Used: {cb.total_tokens}\n"
            f"Prompt Tokens: {cb.prompt_tokens}\n"
            f"Prompt Tokens Cached: {cb.prompt_tokens_cached}\n"
            f"Completion Tokens: {cb.completion_tokens}\n"
            f"Reasoning Tokens: {cb.reasoning_tokens}\n"
            f"Successful Requests: {cb.successful_requests}\n"
            f"Total Cost (USD): ${cb.total_cost}\n")


def project_understanding_agent(state: ScopeState):
    project_understanding_agent_prompt = open(
        f"{INSTRUCTIONS_DIR}/agent_instructions/project_understanding_agent_instructions.md").read()
    agent = create_react_agent(llm, tools=[],
                               prompt=project_understanding_agent_prompt)
    file_name = 'project_understanding.md'
    if state['verification']:
        identifier = 'verifier_agent'
        msg = [
            {
                "role": "user",
                "content": f"Original user query:\n\n{state['query']}. "
                           f"Previously generated content:\n\n{state['requirements']}"
                           f"Suggestions:\n\n{state['verification']}"
            },
        ]
        logger.info("Agent: project understanding, purpose: verification")
    else:
        identifier = "key_objectives_agent"
        msg = [state['messages'][0]]
        logger.info("Agent: project understanding, purpose: documentation")
    response = agent.invoke({'messages': msg}, config={"callbacks": [callback_handler]})
    token_data = generate_token_usage_str(callback_handler)
    logger.info(f"\nToken Data: {token_data}")
    last_message = response['messages'][-1].content
    if last_message:
        open(os.path.join(OUTPUT_DIR, f"01_{file_name}"), 'w').write(f"# Project Requirements: \n\n{last_message}\n\n")
        return Command(goto=identifier,
                       update={"requirements": last_message, 'messages': response['messages'], 'verification': None})
    else:
        logger.error(NO_RESPONSE_MESSAGE)
        return Command(goto=identifier,
                       update={"requirements": "", 'messages': response['messages'], 'verification': None})


def key_objectives_agent(state: ScopeState):
    key_objectives_prompt = open(f"{INSTRUCTIONS_DIR}/agent_instructions/key_objectives_agent_instructions2.md").read()

    agent = create_react_agent(llm, tools=[],
                               prompt=key_objectives_prompt)
    file_name = 'key_objectives.md'
    if state['verification']:
        msg = [
            {
                "role": "user",
                "content": f"Original user query:\n\n{state['query']}. "
                           f"Previously generated content:\n\n{state['objectives']}"
                           f"Suggestions:\n\n{state['verification']}"
            },
        ]
        logger.info("Agent: key objectives, purpose: verification")
        identifier = 'verifier_agent'
    else:
        msg = state['messages'][0]
        logger.info("Agent: key objectives, purpose: documentation")
        identifier = "deliverables_agent"
    response = agent.invoke({'messages': msg}, config={"callbacks": [callback_handler]})
    token_data = generate_token_usage_str(callback_handler)
    logger.info(f"\nToken Data: {token_data}")
    last_message = response['messages'][-1].content
    if last_message:
        open(os.path.join(OUTPUT_DIR, f"02_{file_name}"), 'w').write(f"# Key Objectives: \n\n {last_message}\n\n")
        return Command(goto=identifier,
                       update={"objectives": last_message, 'messages': response['messages'], 'verification': None})
    else:
        logger.error(NO_RESPONSE_MESSAGE)
        return Command(goto=identifier,
                       update={"objectives": "", 'messages': response['messages'], 'verification': None})


def deliverables_agent(state: ScopeState):
    deliverables_prompt = open(f"{INSTRUCTIONS_DIR}/agent_instructions/deliverables_agent_instructions2.md").read()
    agent = create_react_agent(llm, tools=[],
                               prompt=deliverables_prompt)
    file_name = 'deliverables.md'
    if state['verification']:
        msg = [
            {
                "role": "user",
                "content": f"Original user query:\n\n{state['query']}. "
                           f"Previously generated content:\n\n{state['deliverables']}"
                           f"Suggestions:\n\n{state['verification']}"
            },
        ]
        logger.info("Agent: deliverables, purpose: verification")
        identifier = 'verifier_agent'
    else:
        msg = state['messages'][0]
        logger.info("Agent: deliverables, purpose: documentation")
        identifier = "generate_panel_module_actions"
    response = agent.invoke({'messages': msg}, config={"callbacks": [callback_handler]})
    token_data = generate_token_usage_str(callback_handler)
    logger.info(f"\nToken Data: {token_data}")
    last_message = response['messages'][-1].content
    if last_message:
        open(os.path.join(OUTPUT_DIR, f"03_{file_name}"), 'w').write(f"# Deliverables: \n\n{last_message}\n\n")
        return Command(goto=identifier,
                       update={"deliverables": last_message, 'messages': response['messages'], 'verification': None})
    else:
        logger.error(NO_RESPONSE_MESSAGE)
        return Command(goto=identifier,
                       update={"deliverables": "", 'messages': response['messages'], 'verification': None})


def panels_agent(state: ScopeState):
    panels_prompt = open(f"{INSTRUCTIONS_DIR}/agent_instructions/panels_agent_instructions2.md").read()
    agent = create_react_agent(llm, tools=[],
                               prompt=panels_prompt, response_format=EntityList)

    file_name = 'panels.md'
    if state['verification']:
        msg = {
            "role": "user",
            "content": f"Original user query:\n\n{state['query']}. "
                       f"Previously generated content:\n\n{state['panels']}"
                       f"Suggestions:\n\n{state['verification']}"
        }

        logger.info("Agent: panels, purpose: verification")
        identifier = 'verifier_agent'
    else:
        msg = {"messages": state['query']}
        logger.info("Agent: panels, purpose: documentation")
        identifier = None

    response = agent.invoke(msg, config={"callbacks": [callback_handler]})
    token_data = generate_token_usage_str(callback_handler)
    logger.info(f"\nToken Data: {token_data}")
    if response:
        allowed_panel_names = [
            "Web App",
            "Mobile App",
            "Desktop App",
            "Website",
            "WhatsApp",
            "WhatsApp Chatbot",
            "Web Chatbot",
        ]
        panels = response.get('structured_response').entities
        panel = panels[0]

        while True:
            logger.info(f"Panel: {panel.name}")
            if panel.name in allowed_panel_names:
                break
            else:
                logger.info("Updating panel name")
                response = agent.invoke(msg)
                panels = response.get('structured_response').entities
                panel = panels[0]

        if identifier:
            return Command(goto=identifier,
                           update={"panels": panels,
                                   'messages': response['messages'], 'verification': None})
        else:
            data = []
            for panel in panels:
                panel_name = panel.name.replace("INTERFACE", "").strip()
                panel_description = panel.description
                panel_dir = os.path.join(OUTPUT_DIR, "interfaces", panel_name)
                data += f"## {panel_name}: \n- {panel_description}\n\n"
                os.makedirs(panel_dir, exist_ok=True)
                open(os.path.join(panel_dir, "description.md"), 'w').write(panel_description)
            open(os.path.join(OUTPUT_DIR, f"04_{file_name}"), 'w').write(
                f'# Panels/Interfaces: \n\n{"".join(data)}\n\n')

            return {"panels": panels, 'messages': response['messages'],
                    'verification': None}
    else:
        logger.error(NO_RESPONSE_MESSAGE)
        return Command(goto=identifier,
                       update={"panels": "", 'messages': response['messages'], 'verification': None})


def modules_agent(state: ScopeState):
    modules_prompt = open(f"{INSTRUCTIONS_DIR}/agent_instructions/modules_agent_instructions2.md").read()
    agent = create_react_agent(llm, tools=[],
                               prompt=modules_prompt, response_format=EntityList)
    file_name = 'modules.md'
    if state['verification']:
        msg = [
            {
                "role": "user",
                "content": f"Original user query:\n\n{state['query']}. "
                           f"Previously generated content:\n\n{state['panels']}"
                           f"Suggestions:\n\n{state['verification']}"
            },
        ]
        logger.info("Agent: modules, purpose: verification")
        identifier = 'verifier_agent'
    else:
        msg = {"messages": state['panel']}
        logger.info("Agent: modules, purpose: documentation")
        identifier = None

    response = agent.invoke(msg, config={"callbacks": [callback_handler]})
    token_data = generate_token_usage_str(callback_handler)
    logger.info(f"\nToken Data: {token_data}")
    if response:
        modules = response.get('structured_response').entities
        if identifier:
            return Command(goto=identifier,
                           update={"modules": modules,
                                   'messages': response['messages'], 'verification': None})
        else:
            data = []
            panel_name = state['panel_name']
            modules_dir = os.path.join(OUTPUT_DIR, "interfaces", panel_name, "modules")
            os.makedirs(modules_dir, exist_ok=True)

            modules_sequence = []
            for module in modules:
                module_name = module.name.replace("Module", "").strip()
                module_description = module.description
                data += f"## {module_name}: \n- {module_description}\n\n"
                modules_sequence.append(module_name)

            open(f'{modules_dir}/{file_name}', "w").write(f"{'\n'.join(modules_sequence)}")
            return {"modules": modules, 'messages': response['messages'],
                    'verification': None}
    else:
        logger.error(NO_RESPONSE_MESSAGE)
        return Command(goto=identifier,
                       update={"modules": "", 'messages': response['messages'], 'verification': None})


def modules_actions_agent(state: ScopeState):
    modules_actions_prompt = open(
        f"{INSTRUCTIONS_DIR}/agent_instructions/modules_actions_agent_instructions2.md").read()
    agent = create_react_agent(llm, tools=[],
                               prompt=modules_actions_prompt)
    file_name = 'actions.md'
    if state['verification']:
        msg = [
            {
                "role": "user",
                "content": f"Original user query:\n\n{state['query']}. "
                           f"Panel: {state['panel_name']}"
                           f"Suggestions:\n\n{state['verification']}"
            },
        ]
        logger.info("Agent: actions, purpose: verification")
        panel_name = state['panel_name'].replace("INTERFACE", "").strip()
        module_name = state['module_name'].replace("Module", "").strip()
        panel_dir = f"{OUTPUT_DIR}/interfaces/{panel_name}"
        if not os.path.exists(panel_dir):
            logger.info(f"Creating panel: {panel_dir}")
            os.makedirs(panel_dir, exist_ok=True)
        else:
            logger.info(f"Panel {panel_name} already exists.")
        module_file = f"{panel_dir}/modules/{module_name}.md"
        if os.path.exists(module_file):
            content = open(module_file).read()
            msg[0]['content'] += f"Previously generated content:\n\n{content}"
            logger.info(f"Module {module_name} exists.")
        else:
            with open(f"{panel_dir}/modules/modules.md", 'a+') as fL:
                fL.write(f"\n{module_name}")

        identifier = 'verifier_agent'
    else:
        msg = state['module']
        logger.info("Agent: actions, purpose: documentation")
        identifier = None

    response = agent.invoke({'messages': msg}, config={"callbacks": [callback_handler]})
    token_data = generate_token_usage_str(callback_handler)
    logger.info(f"\nToken Data: {token_data}")
    time.sleep(4)
    last_message = response['messages'][-1].content
    if last_message:
        content = f'## {state["module_name"]}\n\n {last_message[last_message.index("\n\n"):]}'
        if identifier:
            open(os.path.join(OUTPUT_DIR, "interfaces", state['panel_name'], "modules", f"{state['module_name']}.md"),
                 'w').write(content)
            return Command(goto=identifier,
                           update={'messages': response['messages'], 'verification': None})
        else:
            open(os.path.join(OUTPUT_DIR, f"06_{file_name}"), 'a+').write(f"{last_message}\n\n")
            open(os.path.join(OUTPUT_DIR, "interfaces", state['panel_name'], "modules", f"{state['module_name']}.md"),
                 'w').write(content)
            return {"modules": content, 'messages': response['messages'], 'verification': None}
    else:
        logger.error(NO_RESPONSE_MESSAGE)
        return Command(goto=identifier,
                       update={"modules": "", 'messages': response['messages'], 'verification': None})


def generate_panel_module_actions(state: ScopeState):
    logger.info(" Agent: panel_module_actions")
    file_name = "07_data.md"
    panels = panels_agent(state)
    state['messages'] = panels.get('messages')
    state['panels'] = panels.get('panels')
    state['whole_data'] = {}
    separator_str = "*******************************************************************************************************************************\n\n"
    with open(os.path.join(OUTPUT_DIR, file_name), 'w') as file:
        file.write(f"# Project Requirements: \n\n{state['requirements']}\n\n")
        file.write(separator_str)
        file.write(f"# Key Objectives: \n\n {state['requirements']}\n\n")
        file.write(separator_str)
        file.write(f"# Project Deliverables: \n\n {state['deliverables']}\n\n")
        file.write(separator_str)
        file.write("# Panels/Interfaces: \n\n")
    data = {}

    for panel in panels.get('panels'):
        panel_name = panel.name.strip()
        panel_description = panel.description

        data[panel_name] = {}
        open(os.path.join(OUTPUT_DIR, file_name), 'a+').write(f"## {panel_name}: \n- {panel_description}\n\n")
        state['panel'] = f"{panel_name}: {panel_description}"
        state['panel_name'] = panel_name
        modules = modules_agent(state).get('modules')
        for module in modules:
            module_name = module.name.strip()
            module_description = module.description
            data[panel_name]['modules'] = {}
            data[panel_name]['modules']['name'] = module_name
            data[panel_name]['modules']['description'] = module_description
            state['module'] = f"{module_name}: {module_description}"
            state['module_name'] = module_name
            open(os.path.join(OUTPUT_DIR, file_name), 'a+').write(f"### {module_name}: \n {module_description}\n\n")
            actions = modules_actions_agent(state).get('modules')
            split_actions = actions.index("###")
            data[panel_name]['modules']['actions'] = actions[split_actions:]
            open(os.path.join(OUTPUT_DIR, file_name), 'a+').write(f"{actions[split_actions:]}\n")
        open(os.path.join(OUTPUT_DIR, file_name), 'a+').write("\n\n"
                                                              "*******************************************************************************************************************************\n\n")

    whole_file_data = open(os.path.join(OUTPUT_DIR, file_name), 'r').read()
    return Command(goto="verifier_agent", update={"whole_file_data": whole_file_data, 'whole_data': data})


def gather_all_outputs() -> str:
    snippets = []
    for fname in sorted(os.listdir(OUTPUT_DIR)):
        if fname.endswith('.md') and fname not in ('all_content.md', 'feedbacks.md', '05_modules.md'):
            with open(os.path.join(OUTPUT_DIR, fname), 'r') as f:
                snippets.append(f.read())
                snippets.append(
                    "\n\n------------------------------------------------------------------------------------------------------------------\n\n")
    combined_data = "\n\n---\n\n".join(snippets)
    open(os.path.join(OUTPUT_DIR, 'all_content.md'), 'w').write(combined_data)
    return combined_data


def create_combined_markdown(root_dir):
    combined_output_file = f"{root_dir}/combined_panels.md"
    if os.path.exists(combined_output_file):
        os.remove(combined_output_file)
    for interface in os.listdir(root_dir):
        item_path = os.path.join(root_dir, interface)
        if os.path.isdir(item_path):
            combined_md_lines = [
                f"---------------------------------------------START: {interface} INTERFACE-----------------------------------\n\n",
                f"# {interface}\n"]

            # Read description.md
            description_path = os.path.join(item_path, "description.md")
            if os.path.exists(description_path):
                with open(description_path, 'r', encoding='utf-8') as f:
                    combined_md_lines.append(f.read() + "\n")

            # Read the module order from modules/modules
            modules_dir = os.path.join(item_path, "modules")
            modules_order_path = os.path.join(modules_dir, "modules.md")
            if os.path.exists(modules_order_path):
                with open(modules_order_path, 'r', encoding='utf-8') as fd:
                    module_files = [line.strip() for line in fd if line.strip()]
                # Read each module in the specified order
                for module_file in module_files:
                    module_path = os.path.join(modules_dir, f"{module_file}.md")
                    if os.path.exists(module_path):
                        with open(module_path, 'r', encoding='utf-8') as mf:
                            combined_md_lines.append("\n\n")
                            combined_md_lines.append(mf.read() + "\n")
                    else:
                        logger.warning(f"Warning: Module file '{module_file}' not found in {modules_dir}")

            # Write to output markdown
            combined_md_lines.append(
                f"----------------------------------END: {interface} INTERFACE--------------------------------------\n\n", )
            output_path = os.path.join(item_path, f"{interface}.md")
            with open(output_path, 'w', encoding='utf-8') as outf:
                outf.writelines(combined_md_lines)
            with open(combined_output_file, 'a+') as cfile:
                cfile.writelines(combined_md_lines)
                cfile.write("\n\n\n")


def combined_file_data():
    file_names = ["01_project_understanding.md", "02_key_objectives.md", "03_deliverables.md"]
    content = []
    for fname in sorted(os.listdir(OUTPUT_DIR)):
        if fname in file_names:
            content.append(
                f"-----------------------------------------------START: {fname}-----------------------------------------------------------\n\n")
            content.append(open(os.path.join(OUTPUT_DIR, fname)).read())
            content.append(
                f"-----------------------------------------------END: {fname}-----------------------------------------------------------\n\n")
    create_combined_markdown(os.path.join(OUTPUT_DIR, "interfaces"))
    panels_data = open(os.path.join(OUTPUT_DIR, "interfaces", "combined_panels.md")).read()
    content += panels_data
    with open(os.path.join(OUTPUT_DIR, "all_content.md"), "w") as f:
        f.writelines(content)
    logger.info("Created output file.")


def verifier_agent(state: ScopeState) -> Command[Literal[*verifier_options, "__end__"]]:
    """
    Supervisor agent to orchestrate task execution by delegating to other agents.
    """
    logger.info("Agent: verifier")
    verifier_agent_prompt = open(f"{INSTRUCTIONS_DIR}/agent_instructions/verifier_agent_instructions6.md").read()

    combined_file_data()
    combined_data = open(os.path.join(OUTPUT_DIR, "all_content.md"), "r").read()

    messages = [
        {"role": "system", "content": verifier_agent_prompt},
        {"role": "user", "content": state['query']},
        {"role": "assistant", "content": combined_data},
    ]
    response = llm.with_structured_output(SimpleRouter).invoke(messages,
                                                               config={"callbacks": [callback_handler]})
    token_data = generate_token_usage_str(callback_handler)
    logger.info(f"\nToken Data: {token_data}")
    logger.info(response, "_______++++++_______")
    if not response or not response.verification:
        logger.info(NO_RESPONSE_MESSAGE)
        return Command(goto="verifier_agent", update={"verification": "please provide response", 'messages': messages,
                                                      'module_name': None, 'panel_name': None})
    goto = response.next
    if goto == "FINISH":
        goto = END
    print(goto, "GOTO")
    feedbacks_file = os.path.join(OUTPUT_DIR, 'feedbacks.md')

    file_content = ""
    if os.path.exists(feedbacks_file):
        content = open(feedbacks_file, 'r').read()
        file_content = content
    with open(feedbacks_file, 'w') as f:
        f.write(f'{file_content}\n\n  {response.verification}\n\n')
    return Command(goto=goto, update={"next": goto, "verification": response.verification, 'messages': messages,
                                      'module_name': response.module_name, 'panel_name': response.panel_name})


Graph = StateGraph(ScopeState)

Graph.add_node('project_understanding_agent', project_understanding_agent)
Graph.add_node('key_objectives_agent', key_objectives_agent)
Graph.add_node('deliverables_agent', deliverables_agent)
Graph.add_node('generate_panel_module_actions', generate_panel_module_actions)
Graph.add_node('panels_agent', panels_agent)
Graph.add_node('modules_agent', modules_agent)
Graph.add_node('modules_actions_agent', modules_actions_agent)
# Graph.add_node('verifier_agent', verifier_agent)

Graph.add_edge(START, 'project_understanding_agent')
Graph.add_edge("modules_actions_agent", END)
# Graph.add_edge(START, 'verifier_agent')

graph = Graph.compile()


def generate_graph(query):
    initial_state = ScopeState(
        messages=[HumanMessage(role="user", content=query)],
        query=query,
        requirements=None,
        objectives=None,
        deliverables=None,
        panels=None,
        verification=None,
        panel=None,
        panel_name=None,
        module=None,
        module_name=None,
        whole_file_data=None,
        whole_data=None
    )
    for _ in graph.stream(initial_state, config=RunnableConfig(recursion_limit=50)):
        logger.info("---------------------------step done --------------------------------")
    combined_file_data()

    return True
